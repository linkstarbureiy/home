<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STUBE Speedcube</title>
    <!-- Essential for module imports in older browsers/environments, though modern ones often handle it. -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <!-- Import map for Three.js modules (Firebase modules removed) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js"
            }
        }
    </script>
    <style>
        /* Basic styling for the body */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
            font-family: 'Inter', sans-serif; /* Using Inter as requested */
            background-color: #ffffff; /* Changed to white */
            color: #96afc8; /* Darker text for readability on white background */
            font-size: 0.7rem; /* Reduced font size */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh; /* Full viewport height */
            padding-top: 10px; /* Reduced padding top */
            box-sizing: border-box;
        }

        /* Container for the game (canvas, controls, timer) */
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 15px; /* Slightly reduced margin */
            border: 2px solid #f0f0d0; /* Updated border color */
            border-radius: 12px; /* Rounded corners */
            padding: 15px; /* Reduced padding */
            background-color: #ffffff; /* Changed to white */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05); /* Softer shadow for white background */
            width: 100%;
            max-width: 350px; /* Adjusted max width for smaller canvas */
            box-sizing: border-box;
        }

        /* Styling for the Three.js canvas */
        #stubeCanvas {
            width: 300px; /* Reduced width */
            height: 250px; /* Reduced height */
            max-width: 100%; /* Ensure responsiveness */
            background-color: #4a5568; /* Canvas background (retained) */
            border-radius: 12px; /* Rounded corners */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            display: block; /* Remove extra space below canvas */
            margin-bottom: 15px; /* Reduced margin */
            touch-action: none; /* Prevent default touch actions like scrolling */
        }

        /* Grid for control buttons (now only scramble, start, reset) */
        #controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 columns */
            gap: 8px; /* Reduced space between buttons */
            margin-top: 15px; /* Reduced margin */
            width: 100%; /* Take full width of container */
            max-width: 300px; /* Align with canvas max-width */
        }

        /* Base button styles */
        .button {
            padding: 8px 15px; /* Reduced padding */
            font-size: 0.7rem; /* Reduced font size */
            font-weight: 600;
            cursor: pointer;
            border: 1px solid #f0f0d0; /* Updated border color */
            border-radius: 6px; /* Slightly reduced rounded corners */
            color: #96afc8; /* New text color */
            background-color: #ffffff; /* Changed to solid white */
            background-image: none; /* Removed gradient */
            transition: all 0.2s ease-in-out;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.05); /* Softer shadow */
            flex: 1 1 auto; /* Allow buttons to grow and shrink */
            min-width: 80px; /* Reduced minimum width for buttons */
        }

        /* Hidden twist buttons for internal scramble logic */
        .twist-button {
            display: none; /* Keep these hidden */
        }

        /* Hover effects for buttons */
        .button:hover {
            transform: translateY(-1px); /* Reduced translateY */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Softer shadow on hover */
            background-color: #f0f0f0; /* Slightly off-white on hover */
        }

        /* Active (click) effects for buttons */
        .button:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.02); /* Even softer shadow on active */
            background-color: #e8e8e8; /* Slightly darker off-white on active */
        }

        /* Specific button colors (now solid white with dark text) */
        #scrambleButton {
            color: #96afc8; /* New text color */
        }
        #startButton {
            color: #96afc8; /* New text color */
        }
        #resetButton {
            color: #96afc8; /* New text color */
        }

        /* Message box styling */
        #messageBox {
            margin-top: 10px; /* Reduced margin */
            padding: 10px 15px; /* Reduced padding */
            background-color: #ffffff; /* Changed to white */
            color: #96afc8; /* New text color */
            border-radius: 8px;
            font-size: 0.8rem; /* Reduced font size */
            text-align: center;
            min-height: 1.5em; /* Reduced min-height */
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 300px; /* Align with controls */
            box-sizing: border-box;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.05); /* Softer shadow */
        }

        /* Moves display */
        #movesDisplay {
            font-size: 0.8rem; /* Reduced font size */
            font-weight: bold;
            color: #96afc8; /* New text color */
            margin-bottom: 8px; /* Reduced margin */
        }

        /* Responsive adjustments */
        @media (max-width: 640px) {
            #stubeCanvas {
                width: 100%; /* Full width on small screens */
                height: 250px; /* Adjusted height for mobile */
            }
            #gameContainer {
                max-width: 100%; /* Allow full width on small screens */
            }
            #controls {
                grid-template-columns: repeat(3, 1fr); /* Keep 3 columns for main buttons */
                max-width: 100%;
            }
            .button {
                min-width: unset; /* Remove min-width constraint */
                font-size: 0.65rem; /* Further reduce font size on small screens */
                padding: 6px 10px;
            }
            #movesDisplay {
                font-size: 0.7rem; /* Adjusted for smaller screens */
            }
            #messageBox {
                font-size: 0.7rem; /* Adjusted for smaller screens */
                padding: 8px 10px;
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="stubeCanvas"></canvas>
        <div id="messageBox"></div>
        <div id="movesDisplay">moves: 0</div>
        <div id="controls">
            <button id="scrambleButton" class="button">scramble</button>
            <button id="startButton" class="button">start</button>
            <button id="resetButton" class="button">reset</button>

            <!-- Hidden twist buttons for internal scramble logic -->
            <button class="twist-button" data-face="U" data-direction="1">U</button>
            <button class="twist-button" data-face="U" data-direction="-1">U'</button>
            <button class="twist-button" data-face="D" data-direction="1">D</button>
            <button class="twist-button" data-face="D" data-direction="-1">D'</button>
            <button class="twist-button" data-face="F" data-direction="1">F</button>
            <button class="twist-button" data-face="F" data-direction="-1">F'</button>
            <button class="twist-button" data-face="B" data-direction="1">B</button>
            <button class="twist-button" data-face="B" data-direction="-1">B'</button>
            <button class="twist-button" data-face="L" data-direction="1">L</button>
            <button class="twist-button" data-face="L" data-direction="-1">L'</button>
            <button class="twist-button" data-face="R" data-direction="1">R</button>
            <button class="twist-button" data-face="R" data-direction="-1">R'</button>
        </div>
    </div>

    <!-- Leaderboard and User ID sections removed as per request -->

    <script type="module">
        // Import Three.js modules (Firebase modules removed)
        import * as THREE from 'three';

        // --- Three.js Setup ---
        let scene, camera, renderer;
        let cubeGroup; // Group for all cubelets, allowing global rotation
        let initialCubeletStates = []; // To store initial positions and rotations for reset
        let currentTwist = null; // To track ongoing twist animation
        let animationProgress = 0;
        const animationDuration = 100; // milliseconds for twist animation
        let targetQuaternion = new THREE.Quaternion();
        let selectedCubelets = []; // Cubelets for the current twist

        // Variables for camera controls (mouse/touch)
        let isDragging = false; // For global cube rotation
        let isLayerDragging = false; // For layer twisting
        let initialMousePos = new THREE.Vector2(); // For global rotation
        let initialIntersection = { // For layer twisting
            object: null,
            faceIndex: -1,
            point: new THREE.Vector3(),
            uv: new THREE.Vector2() // UV coordinates on the face for more precise drag direction
        };
        const dragThreshold = 10; // Pixels to drag before a layer twist is registered (increased for better mobile experience)

        // Game state variables
        let movesCount = 0;
        let isSolved = false;
        const movesDisplay = document.getElementById('movesDisplay');

        // Raycaster and mouse vector for intersection detection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // STUBE Colors (all 6 defined as per user request, with specific hex codes)
        const STUBE_COLORS = {
            YELLOW: new THREE.Color(0xffc800), // Lemon Yellow
            ORANGE: new THREE.Color(0xff821e), // Orange
            GREEN: new THREE.Color(0x00ff00), // Lime Green
            BLUE: new THREE.Color(0x64c8ff),  // Baby Blue
            GRAY: new THREE.Color(0x808080),  // Gray
            WHITE: new THREE.Color(0xffffff)  // White
        };

        // Koala emoji SVG as a data URL for reliability
        const KOALA_EMOJI_URL = 'data:image/svg+xml;base64,' + btoa(`
            <svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect x="0" y="0" width="100" height="100" fill="#64c8ff"/> <!-- Background color matching blue face -->
                <circle cx="50" cy="40" r="30" fill="#808080"/> <!-- Head -->
                <circle cx="30" cy="25" r="12" fill="#808080"/> <!-- Left Ear -->
                <circle cx="70" cy="25" r="12" fill="#808080"/> <!-- Right Ear -->
                <circle cx="50" cy="45" r="8" fill="#333333"/> <!-- Nose -->
                <circle cx="40" cy="40" r="4" fill="white"/> <!-- Left Eye -->
                <circle cx="60" cy="40" r="4" fill="white"/> <!-- Right Eye -->
                <path d="M45 55 Q50 65 55 55" stroke="#333333" stroke-width="3" fill="none"/> <!-- Mouth -->
            </svg>
        `);
        let koalaTexture = null; // Will be loaded asynchronously

        /**
         * Creates a canvas texture with a number or a solid color.
         * If a number is provided, it's drawn on top of the color.
         * @param {THREE.Color} color - The base color for the texture.
         * @param {number|null} number - The number to draw, or null if no number.
         * @param {number} width - Canvas width.
         * @param {number} height - Canvas height.
         * @returns {THREE.CanvasTexture} The created texture.
         */
        function createFaceTexture(color, number = null, width = 64, height = 64) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');

            // Draw the background color
            context.fillStyle = color.getStyle(); // Use getStyle() for THREE.Color
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Draw the number if provided
            if (number !== null) {
                context.font = `Bold ${width * 0.15}px Arial`; // Reduced font size for numbers by half
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillStyle = '#333333'; // Dark color for the number for contrast
                context.fillText(number.toString(), width / 2, height / 2);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        /**
         * Initializes the Three.js scene, camera, renderer, and creates the cube.
         */
        function initCube() {
            const canvas = document.getElementById('stubeCanvas');
            if (!canvas) {
                console.error("Canvas element not found! Cannot initialize Three.js.");
                return;
            }

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a); // Dark background for the 3D scene

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 5); // Position camera back from the cube for a good view

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Adjust for high-DPI screens

            // Lighting setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Soft ambient light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Directional light for shadows/highlights
            directionalLight.position.set(3, 5, 2); // Position of the light source
            scene.add(directionalLight);

            // Create a group to hold all 27 cubelets, allowing the entire cube to be rotated
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);

            // Load Koala Texture for the 27th cubelet (koala bear emoji)
            const loader = new THREE.TextureLoader();
            loader.load(KOALA_EMOJI_URL,
                (texture) => {
                    koalaTexture = texture;
                    createCube(); // Create the cube AFTER the texture is loaded
                    console.log("Koala texture loaded, cube created.");
                    animate(); // Start the animation loop
                },
                undefined, // onProgress callback (optional)
                (error) => {
                    console.error('An error occurred loading the koala texture:', error);
                    // Fallback: Create cube without the koala texture, or use a plain color
                    createCube();
                    animate();
                }
            );

            // Add event listeners for mouse and touch interactions to control camera rotation and layer twisting
            canvas.addEventListener('mousedown', onPointerDown, false);
            canvas.addEventListener('mousemove', onPointerMove, false);
            canvas.addEventListener('mouseup', onPointerUp, false);
            canvas.addEventListener('mouseleave', onPointerUp, false); // Stop dragging if mouse leaves canvas

            canvas.addEventListener('touchstart', onPointerDown, { passive: false }); // Prevent default scrolling
            canvas.addEventListener('touchmove', onPointerMove, { passive: false }); // Prevent default scrolling
            canvas.addEventListener('touchend', onPointerUp, false);

            // Adjust canvas and camera on window resize
            window.addEventListener('resize', onWindowResize, false);

            console.log("Three.js cube initialized.");
        }

        /**
         * Handles window resizing to adjust canvas dimensions and camera aspect ratio.
         */
        function onWindowResize() {
            const canvas = document.getElementById('stubeCanvas');
            if (canvas) {
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            }
        }

        /**
         * Creates a single cubelet (small cube) with colored and numbered faces.
         * The 27th cubelet (ID 27) gets the koala emoji on its back face.
         * @param {number} x - X coordinate (-1, 0, 1)
         * @param {number} y - Y coordinate (-1, 0, 1)
         * @param {number} z - Z coordinate (-1, 0, 1)
         * @param {number} id - Unique ID for the cubelet (1-27).
         * @returns {THREE.Mesh} The created cubelet mesh
         */
        function createCubelet(x, y, z, id) {
            const geometry = new THREE.BoxGeometry(0.98, 0.98, 0.98); // Slightly smaller for visible gaps
            const materials = [];

            // The 27th cubelet is defined as the one with the koala emoji.
            // Based on the numbering scheme (Z, then Y, then X), the 27th cubelet is at (1, 1, 1).
            const isKoalaCubelet = (id === 27);

            // Define face properties: index, axis, value (position on axis), and default color
            const faceData = [
                { index: 0, axis: 'x', value: 1, color: STUBE_COLORS.ORANGE },  // Right (+X)
                { index: 1, axis: 'x', value: -1, color: STUBE_COLORS.GRAY },   // Left (-X)
                { index: 2, axis: 'y', value: 1, color: STUBE_COLORS.YELLOW },  // Top (+Y)
                { index: 3, axis: 'y', value: -1, color: STUBE_COLORS.WHITE },  // Bottom (-Y)
                { index: 4, axis: 'z', value: 1, color: STUBE_COLORS.GREEN },   // Front (+Z)
                { index: 5, axis: 'z', value: -1, color: STUBE_COLORS.BLUE }    // Back (-Z)
            ];

            for (let i = 0; i < 6; i++) {
                let material;
                const faceInfo = faceData.find(f => f.index === i);

                // Determine if this face is an "outer" face of the cube
                const isOuterFace = (
                    (faceInfo.axis === 'x' && x === faceInfo.value) ||
                    (faceInfo.axis === 'y' && y === faceInfo.value) ||
                    (faceInfo.axis === 'z' && z === faceInfo.value)
                );

                // Apply Koala texture if it's the specific koala cubelet and its back face
                if (isKoalaCubelet && i === 5 && koalaTexture) { // Back face is index 5
                    material = new THREE.MeshLambertMaterial({ map: koalaTexture });
                } else if (isOuterFace) {
                    // For outer faces, if it's the koala cubelet, don't number it. Otherwise, number it.
                    const faceColor = faceInfo.color;
                    const numberToDisplay = isKoalaCubelet ? null : id; // Display number only if NOT the koala cubelet
                    const numberedFaceTexture = createFaceTexture(faceColor, numberToDisplay);
                    material = new THREE.MeshLambertMaterial({ map: numberedFaceTexture });
                } else {
                    // Inner faces (not exposed to the outside) get a dark grey color
                    material = new THREE.MeshLambertMaterial({ color: 0x333333 });
                }
                materials.push(material);
            }

            const cubelet = new THREE.Mesh(geometry, materials);
            cubelet.position.set(x, y, z);

            // Store initial position and rotation (quaternion) for solved state checking and reset
            cubelet.userData.initialPosition = cubelet.position.clone();
            cubelet.userData.initialQuaternion = cubelet.quaternion.clone();
            cubelet.userData.id = id; // Store the ID in userData for debugging/reference
            initialCubeletStates.push({
                position: cubelet.position.clone(),
                quaternion: cubelet.quaternion.clone(),
                id: id // Also store ID in the initial states array
            });

            return cubelet;
        }

        /**
         * Creates all 27 cubelets and adds them to the main cubeGroup.
         * This function is called after the koala texture is loaded.
         */
        function createCube() {
            // Clear any existing cubelets if this function is called multiple times (e.g., on reset)
            if (cubeGroup && cubeGroup.children.length > 0) {
                cubeGroup.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            m.dispose();
                        }
                    }
                });
                cubeGroup.remove(...cubeGroup.children);
                initialCubeletStates = []; // Clear stored initial states
            }

            let idCounter = 1;
            // Iterate through a 3x3x3 grid to create each cubelet
            // Numbering order: Z (back to front), then Y (bottom to top), then X (left to right)
            for (let z = -1; z <= 1; z++) {
                for (let y = -1; y <= 1; y++) {
                    for (let x = -1; x <= 1; x++) {
                        const cubelet = createCubelet(x, y, z, idCounter++);
                        cubeGroup.add(cubelet);
                    }
                }
            }
            console.log(`Created ${cubeGroup.children.length} cubelets.`);
        }

        /**
         * The main animation loop for Three.js.
         * Continuously renders the scene and updates twist animations.
         */
        function animate() {
            requestAnimationFrame(animate);

            // Handle ongoing twist animation
            if (currentTwist) {
                animationProgress += 16; // Advance animation time (approx. 60 FPS)
                const alpha = Math.min(1, animationProgress / animationDuration); // Progress from 0 to 1

                // Interpolate rotation smoothly using Slerp (Spherical Linear Interpolation)
                currentTwist.tempGroup.quaternion.slerpQuaternions(currentTwist.startRotation, currentTwist.targetRotation, alpha);

                if (alpha === 1) {
                    // Animation finished: clean up and re-parent cubelets
                    const tempGroup = currentTwist.tempGroup;
                    const axis = currentTwist.axis;
                    const angle = currentTwist.angle;

                    // Apply the final rotation to each cubelet's own transform
                    // This is crucial for correctly updating their individual positions/rotations
                    selectedCubelets.forEach(cubelet => {
                        // Apply the rotation matrix to the cubelet's current matrix
                        const rotationMatrix = new THREE.Matrix4().makeRotationAxis(axis, angle);
                        cubelet.applyMatrix4(rotationMatrix);
                    });

                    // Re-add cubelets to the main cubeGroup, removing them from the temporary group
                    selectedCubelets.forEach(cubelet => {
                        cubeGroup.attach(cubelet); // attach preserves world position/rotation
                    });

                    scene.remove(tempGroup); // Remove temporary group from the scene
                    tempGroup.clear(); // Clear children from tempGroup

                    snapCubeletsToGrid(); // Snap to nearest 90-degree alignment to prevent floating point errors
                    currentTwist = null; // Clear current twist state
                    selectedCubelets = []; // Clear selected cubelets

                    // Only check solved state if it was a user-initiated twist (not scramble)
                    if (!currentTwist || currentTwist.source !== 'SCRAMBLE_INTERNAL') {
                        checkSolved();
                    }
                }
            }

            // Render the scene from the camera's perspective
            renderer.render(scene, camera);
        }

        /**
         * Helper function to snap cubelet positions and rotations to the nearest grid.
         * This helps prevent floating point inaccuracies from accumulating during rotations.
         */
        function snapCubeletsToGrid() {
            cubeGroup.children.forEach(cubelet => {
                // Round position components to nearest integer
                cubelet.position.x = Math.round(cubelet.position.x);
                cubelet.position.y = Math.round(cubelet.position.y);
                cubelet.position.z = Math.round(cubelet.position.z);

                // Snap rotation to nearest 90-degree angle
                const quaternion = cubelet.quaternion;
                const euler = new THREE.Euler().setFromQuaternion(quaternion, 'XYZ'); // Convert to Euler angles (order matters)
                euler.x = Math.round(euler.x / (Math.PI / 2)) * (Math.PI / 2);
                euler.y = Math.round(euler.y / (Math.PI / 2)) * (Math.PI / 2);
                euler.z = Math.round(euler.z / (Math.PI / 2)) * (Math.PI / 2);
                cubelet.quaternion.setFromEuler(euler); // Convert back to quaternion
            });
        }

        /**
         * Twists a specific layer of the cube.
         * @param {string} face - The face to twist ('U', 'D', 'F', 'B', 'L', 'R').
         * @param {number} direction - 1 for clockwise, -1 for counter-clockwise.
         * @param {string} [source] - Optional parameter to indicate if the twist is internal (e.g., scramble).
         */
        function twistLayer(face, direction, source = '') {
            if (currentTwist) {
                showMessageBox("Please wait for the current twist to finish!");
                return; // Prevent new twists while one is in progress
            }

            // Increment moves count only if it's a user-initiated twist (not scramble)
            if (source !== 'SCRAMBLE_INTERNAL') {
                movesCount++;
                if (movesDisplay) {
                    movesDisplay.textContent = `moves: ${movesCount}`;
                }
            }

            selectedCubelets = []; // Reset selected cubelets for the new twist
            const axis = new THREE.Vector3();
            let angle = Math.PI / 2 * direction; // 90 degrees or -90 degrees

            // Determine which cubelets belong to the layer and the axis of rotation
            switch (face) {
                case 'U': // Up face (Y=1 layer), rotate around Y-axis
                    selectedCubelets = cubeGroup.children.filter(c => Math.round(c.position.y) === 1);
                    axis.set(0, 1, 0);
                    break;
                case 'D': // Down face (Y=-1 layer), rotate around Y-axis (opposite direction)
                    selectedCubelets = cubeGroup.children.filter(c => Math.round(c.position.y) === -1);
                    axis.set(0, 1, 0);
                    angle *= -1; // Reverse direction for 'D' move
                    break;
                case 'F': // Front face (Z=1 layer), rotate around Z-axis
                    selectedCubelets = cubeGroup.children.filter(c => Math.round(c.position.z) === 1);
                    axis.set(0, 0, 1);
                    break;
                case 'B': // Back face (Z=-1 layer), rotate around Z-axis (opposite direction)
                    selectedCubelets = cubeGroup.children.filter(c => Math.round(c.position.z) === -1);
                    axis.set(0, 0, 1);
                    angle *= -1; // Reverse direction for 'B' move
                    break;
                case 'L': // Left face (X=-1 layer), rotate around X-axis (opposite direction)
                    selectedCubelets = cubeGroup.children.filter(c => Math.round(c.position.x) === -1);
                    axis.set(1, 0, 0);
                    angle *= -1; // Reverse direction for 'L' move
                    break;
                case 'R': // Right face (X=1 layer), rotate around X-axis
                    selectedCubelets = cubeGroup.children.filter(c => Math.round(c.position.x) === 1);
                    axis.set(1, 0, 0);
                    break;
                default:
                    console.warn("Invalid face for twist:", face);
                    return;
            }

            if (selectedCubelets.length === 0) {
                console.warn(`No cubelets found for face ${face}.`);
                return;
            }

            // Create a temporary group to perform the rotation animation
            const tempGroup = new THREE.Group();
            selectedCubelets.forEach(cubelet => {
                cubeGroup.remove(cubelet); // Remove from main group
                tempGroup.add(cubelet);    // Add to temporary group
            });
            scene.add(tempGroup); // Add the temporary group to the scene

            // Store initial rotation of the temporary group and calculate the target rotation
            const startRotation = tempGroup.quaternion.clone();
            targetQuaternion.setFromAxisAngle(axis, angle);
            targetQuaternion.multiplyQuaternions(targetQuaternion, startRotation); // Combine rotations

            // Initialize current twist animation state
            animationProgress = 0;
            currentTwist = {
                startRotation: startRotation,
                currentRotation: tempGroup.quaternion.clone(),
                targetRotation: targetQuaternion,
                axis: axis,
                angle: angle,
                tempGroup: tempGroup,
                source: source // Store source for animation completion check
            };
        }

        // --- Game Logic Functions ---

        /**
         * Displays a message in the designated message box element.
         * @param {string} message - The message text to display.
         */
        function showMessageBox(message) {
            const msgBox = document.getElementById('messageBox');
            if (msgBox) {
                msgBox.textContent = message;
            }
        }

        /**
         * Scrambles the cube by applying a series of random twists.
         * Resets the moves count before scrambling.
         */
        function scrambleCube() {
            resetMoves(); // Reset moves display
            isSolved = false; // Cube is no longer solved

            // Reset cubelets to their initial, solved state before scrambling
            resetCubeletsToInitialState();

            const moves = ['F', 'B', 'U', 'D', 'R', 'L']; // Possible faces to twist
            const scrambleLength = 20; // Number of random twists for the scramble

            // Generate a sequence of random moves
            const scrambleSequence = [];
            for (let i = 0; i < scrambleLength; i++) {
                const randomFace = moves[Math.floor(Math.random() * moves.length)];
                const randomDirection = Math.random() > 0.5 ? 1 : -1; // Clockwise or counter-clockwise
                scrambleSequence.push({ face: randomFace, direction: randomDirection });
            }

            // Apply each scramble move with a small delay for visual effect
            scrambleSequence.forEach((move, i) => {
                // Pass 'SCRAMBLE_INTERNAL' source to bypass moves count during scramble
                setTimeout(() => twistLayer(move.face, move.direction, 'SCRAMBLE_INTERNAL'), i * (animationDuration + 20)); // Wait for animation + small buffer
            });

            showMessageBox("Cube scrambled!");
        }

        /**
         * Resets the cube to its solved state (all cubelets in original position and orientation).
         * Resets the moves count.
         */
        function resetCube() {
            resetMoves(); // Reset moves display
            isSolved = true; // Mark as solved
            resetCubeletsToInitialState(); // Put all cubelets back to their original state
            showMessageBox("Cube reset to solved state.");
        }

        /**
         * Helper function to physically reset all cubelets in the `cubeGroup`
         * to their initially stored positions and rotations.
         */
        function resetCubeletsToInitialState() {
            cubeGroup.children.forEach((cubelet) => {
                // Find the original state for this specific cubelet using its initial position (unique identifier)
                const originalCubeletState = initialCubeletStates.find(state =>
                    state.id === cubelet.userData.id
                );
                if (originalCubeletState) {
                    // Apply the original position and quaternion
                    cubelet.position.copy(originalCubeletState.position);
                    cubelet.quaternion.copy(originalCubeletState.quaternion);
                }
            });
            // Also ensure the main cubeGroup itself is reset to its original orientation
            cubeGroup.rotation.set(0, 0, 0);
            cubeGroup.quaternion.set(0, 0, 0, 1); // Reset to identity quaternion
            snapCubeletsToGrid(); // Ensure perfect alignment after reset
        }

        /**
         * Checks if the cube is currently in a solved state.
         * A cube is considered solved if every cubelet is in its original position and orientation.
         * @returns {boolean} True if the cube is solved, false otherwise.
         */
        function checkSolved() {
            let solved = true;
            // Iterate through all cubelets currently in the cubeGroup
            for (let i = 0; i < cubeGroup.children.length; i++) {
                const cubelet = cubeGroup.children[i];
                const initialPos = cubelet.userData.initialPosition;
                const initialQuat = cubelet.userData.initialQuaternion;

                // Check position: Round current position to nearest integer to account for floating point inaccuracies
                const currentPos = new THREE.Vector3(
                    Math.round(cubelet.position.x),
                    Math.round(cubelet.position.y),
                    Math.round(cubelet.position.z)
                );

                // Check rotation (quaternion): Compare current quaternion to initial quaternion
                // Use a small tolerance for floating point comparisons, and account for q and -q being equivalent
                const quaternionTolerance = 0.001;
                const dotProduct = cubelet.quaternion.dot(initialQuat);
                const isQuaternionEqual = Math.abs(dotProduct) > (1 - quaternionTolerance);

                // If either position or rotation does not match the initial state, the cube is not solved
                if (!currentPos.equals(initialPos) || !isQuaternionEqual) {
                    solved = false;
                    break; // No need to check further
                }
            }

            // If the cube is solved and was not previously marked as solved, display message
            if (solved && !isSolved) {
                isSolved = true;
                showMessageBox(`Congratulations! Cube solved in ${movesCount} moves!`);
            }
            return solved;
        }

        // --- Moves Count Control Functions ---
        /**
         * Resets the moves count display to zero.
         */
        function resetMoves() {
            movesCount = 0;
            if (movesDisplay) {
                movesDisplay.textContent = 'moves: 0';
            }
            isSolved = false; // Ensure cube is not marked as solved (unless explicitly reset to solved state)
        }

        // --- Pointer (Mouse/Touch) Event Handlers ---

        /**
         * Converts screen coordinates to normalized device coordinates (NDC).
         * @param {number} clientX - The clientX from mouse/touch event.
         * @param {number} clientY - The clientY from mouse/touch event.
         * @returns {THREE.Vector2} NDC coordinates.
         */
        function getNormalizedDeviceCoordinates(clientX, clientY) {
            const canvas = renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            return mouse;
        }

        /**
         * Handles pointer down event (mouse or touch) to initiate interaction.
         * @param {Event} event - The pointer event.
         */
        function onPointerDown(event) {
            // Prevent default touch actions like scrolling
            event.preventDefault();

            // Get client coordinates (handle both mouse and touch)
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            // Update mouse vector for raycasting
            getNormalizedDeviceCoordinates(clientX, clientY);

            // Perform raycasting
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubeGroup.children);

            if (intersects.length > 0) {
                // If a cubelet is intersected, we might be starting a layer twist
                const intersect = intersects[0];
                initialIntersection.object = intersect.object;
                initialIntersection.faceIndex = intersect.faceIndex;
                initialIntersection.point.copy(intersect.point);
                // Store initial UV for more precise drag direction on face
                initialIntersection.uv.copy(intersect.uv);
                isLayerDragging = true; // Flag for potential layer drag
                isDragging = false; // Disable global rotation for now
            } else {
                // No cubelet intersected, initiate global cube rotation
                isDragging = true;
                isLayerDragging = false;
            }

            // Store initial mouse position for both global and layer dragging
            initialMousePos.set(clientX, clientY);
        }

        /**
         * Handles pointer move event (mouse or touch) for interaction.
         * @param {Event} event - The pointer event.
         */
        function onPointerMove(event) {
            // Prevent default touch actions like scrolling
            event.preventDefault();

            // Get client coordinates (handle both mouse and touch)
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            const currentMousePos = new THREE.Vector2(clientX, clientY);
            const deltaX = currentMousePos.x - initialMousePos.x;
            const deltaY = currentMousePos.y - initialMousePos.y;

            // If a layer twist is potentially in progress
            if (isLayerDragging) {
                // Check if drag threshold is met for a layer twist
                if (Math.abs(deltaX) > dragThreshold || Math.abs(deltaY) > dragThreshold) {
                    const { object, faceIndex } = initialIntersection;
                   
                    // Get the normal of the intersected face in world coordinates
                    const faceNormal = object.geometry.faces[faceIndex].normal.clone();
                    faceNormal.applyQuaternion(object.quaternion); // Apply cubelet's rotation
                    faceNormal.applyQuaternion(cubeGroup.quaternion); // Apply cubeGroup's rotation
                    faceNormal.normalize();

                    let face = '';
                    let direction = 0;

                    // Determine the primary axis of the drag
                    const isHorizontalDrag = Math.abs(deltaX) > Math.abs(deltaY);

                    // Determine the layer twist based on the face normal and drag direction
                    // This logic is simplified and assumes a standard cube orientation.
                    // More robust solutions might involve transforming drag vectors into the cube's local space.

                    // U/D faces (Y-axis rotation)
                    if (Math.abs(faceNormal.y) > 0.8) { // If it's mostly a top/bottom face
                        if (isHorizontalDrag) {
                            // Dragging left/right on U/D face
                            if (faceNormal.y > 0) { // U face
                                direction = (deltaX > 0) ? -1 : 1; // Right drag is U', Left drag is U
                            } else { // D face
                                direction = (deltaX > 0) ? 1 : -1; // Right drag is D, Left drag is D'
                            }
                            face = (faceNormal.y > 0) ? 'U' : 'D';
                        }
                    }
                    // F/B faces (Z-axis rotation)
                    else if (Math.abs(faceNormal.z) > 0.8) { // If it's mostly a front/back face
                        if (isHorizontalDrag) {
                            // Dragging left/right on F/B face
                            if (faceNormal.z > 0) { // F face
                                direction = (deltaX > 0) ? 1 : -1; // Right drag is F, Left drag is F'
                            } else { // B face
                                direction = (deltaX > 0) ? -1 : 1; // Right drag is B', Left drag is B
                            }
                            face = (faceNormal.z > 0) ? 'F' : 'B';
                        } else {
                            // Vertical drag on F/B face (less common for standard notation but possible)
                            if (faceNormal.z > 0) { // F face
                                direction = (deltaY > 0) ? -1 : 1; // Down drag is F', Up drag is F
                            } else { // B face
                                direction = (deltaY > 0) ? 1 : -1; // Down drag is B, Up drag is B'
                            }
                            face = (faceNormal.z > 0) ? 'F' : 'B';
                        }
                    }
                    // L/R faces (X-axis rotation)
                    else if (Math.abs(faceNormal.x) > 0.8) { // If it's mostly a left/right face
                        if (!isHorizontalDrag) { // Vertical drag
                            // Dragging up/down on L/R face
                            if (faceNormal.x > 0) { // R face
                                direction = (deltaY > 0) ? -1 : 1; // Down drag is R', Up drag is R
                            } else { // L face
                                direction = (deltaY > 0) ? 1 : -1; // Down drag is L, Up drag is L'
                            }
                            face = (faceNormal.x > 0) ? 'R' : 'L';
                        }
                    }

                    if (face && direction !== 0) {
                        twistLayer(face, direction);
                        isLayerDragging = false; // Twist initiated, stop layer dragging
                        isDragging = false; // Also stop global dragging
                    }
                }
            }
            // If not layer dragging, and global dragging is enabled (e.g., drag started on background)
            else if (isDragging) {
                // Global cube rotation
                cubeGroup.rotation.y += deltaX * 0.005;
                cubeGroup.rotation.x += deltaY * 0.005;
            }

            initialMousePos.set(clientX, clientY); // Update previous mouse position for next frame
        }

        /**
         * Handles pointer up event (mouse or touch) to end interaction.
         * @param {Event} event - The pointer event.
         */
        function onPointerUp() {
            isDragging = false;
            isLayerDragging = false;
            initialIntersection.object = null; // Clear intersection data
        }

        // --- Main Initialization on DOM Content Loaded ---
        document.addEventListener('DOMContentLoaded', () => {
            // A defensive check function to ensure all required DOM elements are available
            // before initializing Three.js and attaching event listeners.
            const checkElementsAndInit = () => {
                const canvas = document.getElementById('stubeCanvas');
                const scrambleButton = document.getElementById('scrambleButton');
                const startButton = document.getElementById('startButton');
                const resetButton = document.getElementById('resetButton');
                const movesDisplayElement = document.getElementById('movesDisplay');

                // Check if all critical elements are present
                if (canvas && scrambleButton && startButton && resetButton && movesDisplayElement) {
                    console.log("All required DOM elements found. Initializing cube and listeners.");
                    initCube(); // Initialize the Three.js cube

                    // Attach event listeners to buttons
                    scrambleButton.addEventListener('click', scrambleCube);
                    // The 'Start' button now just resets moves and indicates readiness
                    startButton.addEventListener('click', () => {
                        resetMoves();
                        showMessageBox("Game started! Make your first move.");
                    });
                    resetButton.addEventListener('click', resetCube);

                } else {
                    // If elements are not yet ready, retry after a short delay
                    console.log("Waiting for all required DOM elements to be available...");
                    setTimeout(checkElementsAndInit, 50);
                }
            };

            checkElementsAndInit(); // Start the checking process
        });
    </script>
</body>
</html>
