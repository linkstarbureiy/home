<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D STUBE Cube</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            height: 100%; /* Ensure html and body take full viewport height */
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            font-family: "Inter", sans-serif;
            background-color: #1a202c; /* Dark background */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #e2e8f0;
        }
        canvas {
            display: block;
            background-color: #2d3748; /* Slightly lighter dark background for canvas */
            border-radius: 1rem; /* Rounded corners for canvas */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 100%; /* Take full width of parent */
            height: 100%; /* Take full height of parent */
            max-width: 90vw; /* Max width relative to viewport */
            max-height: 70vh; /* Max height relative to viewport */
            object-fit: contain; /* Ensures the canvas content scales within its bounds */
        }
        .controls-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: center;
            max-width: 90vw;
            padding-bottom: 1rem; /* Add some padding at the bottom */
        }
        button {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            background-color: #4a5568; /* Darker button background */
            color: #e2e8f0;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            font-weight: bold;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        button:hover {
            background-color: #636b77; /* Lighter on hover */
            transform: translateY(-1px);
        }
        button:active {
            background-color: #2d3748; /* Even darker on active */
            transform: translateY(0);
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none; /* Hidden by default */
            text-align: center;
        }
        .message-box button {
            margin-top: 15px;
            background-color: #4a5568;
            color: #e2e8f0;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1 class="text-3xl font-bold mb-4">3D STUBE Cube</h1>
    <canvas id="stubeCubeCanvas"></canvas>

    <div class="controls-container">
        <button onclick="scrambleCube()">Scramble Cube</button>
        <button onclick="resetCube()">Reset Cube</button>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button onclick="hideMessageBox()">OK</button>
    </div>

    <!-- Three.js and OrbitControls Libraries -->
    <!-- Using Three.js r128 and its corresponding OrbitControls.js from examples/js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- This specific OrbitControls.js version is designed to attach to the global THREE object -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <!-- Main script for the cube logic -->
    <script>
        // Function to display messages to the user
        function showMessageBox(message) {
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            messageText.textContent = message;
            messageBox.style.display = 'block';
        }

        function hideMessageBox() {
            const messageBox = document.getElementById('messageBox');
            messageBox.style.display = 'none';
        }

        // --- STUBE Cube 3D Logic (Global variables for Three.js) ---
        let scene, camera, renderer, controls;
        const cubelets = []; // Array to hold all 27 small cubes
        const cubeletGap = 0.05; // Small gap between cubelets for visual separation
        const animationDuration = 200; // milliseconds for rotation animation

        // STUBE Cube colors: lemon yellow, lime green, and baby blue
        const stubeColors = {
            lemonYellow: 0xFFF44F, // Used for Up and Down faces
            limeGreen: 0x32CD32,   // Used for Front and Back faces
            babyBlue: 0x89CFF0,    // Used for Left and Right faces
            black: 0x000000        // Inner faces
        };

        // Function to create a single cubelet (small cube)
        function createCubelet(x, y, z) {
            const geometry = new THREE.BoxGeometry(1, 1, 1); // Each cubelet is 1x1x1
            // Define materials for each face (Right, Left, Top, Bottom, Front, Back)
            const materials = [
                new THREE.MeshLambertMaterial({ color: (x === 1) ? stubeColors.babyBlue : stubeColors.black }),   // Right (+X)
                new THREE.MeshLambertMaterial({ color: (x === -1) ? stubeColors.babyBlue : stubeColors.black }),  // Left (-X)
                new THREE.MeshLambertMaterial({ color: (y === 1) ? stubeColors.lemonYellow : stubeColors.black }),  // Top (+Y)
                new THREE.MeshLambertMaterial({ color: (y === -1) ? stubeColors.lemonYellow : stubeColors.black }), // Bottom (-Y)
                new THREE.MeshLambertMaterial({ color: (z === 1) ? stubeColors.limeGreen : stubeColors.black }),    // Front (+Z)
                new THREE.MeshLambertMaterial({ color: (z === -1) ? stubeColors.limeGreen : stubeColors.black })  // Back (-Z)
            ];

            const cubelet = new THREE.Mesh(geometry, materials);
            // Position cubelet based on its grid coordinates
            cubelet.position.set(x * (1 + cubeletGap), y * (1 + cubeletGap), z * (1 + cubeletGap));
            cubelet.userData = { initialPos: new THREE.Vector3(x, y, z), currentPos: new THREE.Vector3(x, y, z) }; // Store original and current grid position
            scene.add(cubelet);
            return cubelet;
        }

        // Initialize the 3D scene
        function init() {
            const canvas = document.getElementById('stubeCubeCanvas');

            // Ensure THREE.js is loaded and its core components are available
            console.log("DEBUG: init() called. Checking THREE availability.");
            console.log("DEBUG: typeof THREE:", typeof THREE);
            console.log("DEBUG: typeof THREE.Scene:", typeof THREE.Scene);
            if (typeof THREE === 'undefined' || typeof THREE.Scene === 'undefined') {
                console.error("ERROR: THREE.js core library not found or not fully loaded. Please check the script tag for three.min.js and your network connection.");
                showMessageBox("Error: THREE.js core library not loaded.");
                return;
            }

            // Ensure OrbitControls is loaded and attached to THREE
            console.log("DEBUG: init() checking typeof THREE.OrbitControls:", typeof THREE.OrbitControls);
            if (typeof THREE.OrbitControls === 'undefined') {
                console.error("ERROR: THREE.OrbitControls not found. Please check the script tag for OrbitControls.js from examples/js and its compatibility with THREE.js version.");
                showMessageBox("Error: OrbitControls library not loaded or accessible.");
                return;
            }

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // soft white light
            scene.add(ambientLight);

            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5).normalize();
            scene.add(directionalLight);

            // Create 27 cubelets
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        cubelets.push(createCubelet(x, y, z));
                    }
                }
            }

            camera.position.z = 5; // Initial camera position

            // At this point, we are confident THREE and THREE.OrbitControls should be available.
            // Instantiate OrbitControls directly.
            try {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true; // smooth camera movement
                controls.dampingFactor = 0.25;
                controls.screenSpacePanning = false;
                controls.maxDistance = 10;
                controls.minDistance = 3;
            } catch (e) {
                console.error("ERROR: Unexpected error during OrbitControls instantiation:", e);
                showMessageBox("Error: An unexpected error occurred while setting up cube controls. Details: " + e.message);
                return; // Stop initialization if controls cannot be set up
            }

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize(); // Initial call to set size

            animate(); // Start the animation loop
        }

        // Handle window resize
        function onWindowResize() {
            const canvas = document.getElementById('stubeCubeCanvas');
            // Get the actual computed dimensions of the canvas
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            if (controls) { // Ensure controls exist before updating
                controls.update();
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (controls) { // Only update controls if they were successfully initialized
                controls.update(); // only required if controls.enableDamping is set to true
            }
            renderer.render(scene, camera);
        }

        // --- STUBE Cube Logic for Rotations ---
        let isAnimating = false; // Flag to prevent multiple rotations at once

        /**
         * Rotates a specific face of the STUBE Cube.
         * This function is used internally by scrambleCube and resetCube.
         * @param {string} face - 'U', 'D', 'L', 'R', 'F', 'B'
         * @param {boolean} prime - True for counter-clockwise (prime) rotation, false for clockwise.
         */
        function rotateFace(face, prime) {
            if (isAnimating) return; // Prevent rotation if another animation is in progress
            isAnimating = true;

            let axis;
            let value; // The coordinate value that defines the layer
            let rotationAngle = Math.PI / 2; // 90 degrees in radians

            if (prime) {
                rotationAngle *= -1; // Counter-clockwise
            }

            // Determine axis and layer value based on face
            switch (face) {
                case 'U': // Up face (Y-axis, y=1)
                    axis = new THREE.Vector3(0, 1, 0);
                    value = 1;
                    break;
                case 'D': // Down face (Y-axis, y=-1)
                    axis = new THREE.Vector3(0, 1, 0);
                    value = -1;
                    rotationAngle *= -1; // D and D' are opposite to U and U'
                    break;
                case 'L': // Left face (X-axis, x=-1)
                    axis = new THREE.Vector3(1, 0, 0);
                    value = -1;
                    rotationAngle *= -1; // L and L' are opposite to R and R'
                    break;
                case 'R': // Right face (X-axis, x=1)
                    axis = new THREE.Vector3(1, 0, 0);
                    value = 1;
                    break;
                case 'F': // Front face (Z-axis, z=1)
                    axis = new THREE.Vector3(0, 0, 1);
                    value = 1;
                    break;
                case 'B': // Back face (Z-axis, z=-1)
                    axis = new THREE.Vector3(0, 0, 1);
                    value = -1;
                    rotationAngle *= -1; // B and B' are opposite to F and F'
                    break;
                default:
                    isAnimating = false;
                    return;
            }

            // Select cubelets for the current face
            const selectedCubelets = cubelets.filter(cubelet => {
                const currentPos = cubelet.userData.currentPos;
                if (face === 'U' || face === 'D') return Math.round(currentPos.y) === value;
                if (face === 'L' || face === 'R') return Math.round(currentPos.x) === value;
                if (face === 'F' || face === 'B') return Math.round(currentPos.z) === value;
                return false;
            });

            // Create a temporary group for rotation
            const rotationGroup = new THREE.Group();
            scene.add(rotationGroup);

            // Move selected cubelets to the temporary group
            selectedCubelets.forEach(cubelet => {
                scene.remove(cubelet); // Remove from scene
                rotationGroup.attach(cubelet); // Attach to group (maintains world position)
            });

            // Animate the rotation
            const startRotation = rotationGroup.quaternion.clone();
            const endRotation = new THREE.Quaternion().setFromAxisAngle(axis, rotationAngle).multiply(startRotation);

            const startTime = performance.now();

            function animateRotation() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / animationDuration, 1);

                rotationGroup.quaternion.slerpQuaternions(startRotation, endRotation, progress);

                if (progress < 1) {
                    requestAnimationFrame(animateRotation);
                } else {
                    // Animation complete: detach cubelets and update their positions/orientations
                    selectedCubelets.forEach(cubelet => {
                        rotationGroup.remove(cubelet); // Remove from group
                        scene.add(cubelet); // Add back to scene

                        // Update cubelet's current grid position based on its new world position
                        // We need to round to nearest integer because of floating point inaccuracies
                        cubelet.userData.currentPos.copy(cubelet.position).divideScalar(1 + cubeletGap).round();
                    });

                    scene.remove(rotationGroup); // Remove temporary group
                    rotationGroup.clear(); // Clear children from group
                    isAnimating = false; // Allow next rotation
                }
            }
            animateRotation();
        }

        /**
         * Scrambles the cube by performing a series of random rotations.
         */
        function scrambleCube() {
            if (isAnimating) {
                showMessageBox("Please wait for the current animation to finish.");
                return;
            }

            const moves = ['U', 'D', 'L', 'R', 'F', 'B'];
            const numMoves = 20; // Number of random moves to scramble

            let i = 0;
            function performNextMove() {
                if (i < numMoves) {
                    const randomFace = moves[Math.floor(Math.random() * moves.length)];
                    const randomPrime = Math.random() < 0.5; // True for prime, false for regular

                    rotateFace(randomFace, randomPrime);

                    // Wait for the animation to complete before performing the next move
                    const checkAnimation = setInterval(() => {
                        if (!isAnimating) {
                            clearInterval(checkAnimation);
                            i++;
                            performNextMove();
                        }
                    }, 50); // Check every 50ms
                } else {
                    showMessageBox("Cube scrambled!");
                }
            }
            performNextMove();
        }

        /**
         * Resets the cube to its solved state.
         * This is done by recreating all cubelets.
         */
        function resetCube() {
            if (isAnimating) {
                showMessageBox("Please wait for the current animation to finish.");
                return;
            }
            // Remove all existing cubelets from the scene
            cubelets.forEach(cubelet => scene.remove(cubelet));
            cubelets.length = 0; // Clear the array

            // Recreate all cubelets in their initial positions
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        cubelets.push(createCubelet(x, y, z));
                    }
                }
            }
            showMessageBox("Cube has been reset to its solved state!");
        }

        // Expose functions to global scope for HTML buttons
        window.scrambleCube = scrambleCube;
        window.resetCube = resetCube;
        window.showMessageBox = showMessageBox; // Expose for internal use
        window.hideMessageBox = hideMessageBox; // Expose for internal use

        // Initialize the 3D cube when the window loads
        window.addEventListener('load', init);

    </script>
</body>
</html>
